<h2>OOP - Lập trình hướng đối tượng</h2>

<p>Lập trình hướng đối tượng (OOP) là mô hình lập trình dựa trên khái niệm "đối tượng", chứa dữ liệu (thuộc tính) và mã (phương thức). Java là ngôn ngữ OOP thuần túy. OOP trong Java dựa trên bốn trụ cột: <strong>Encapsulation</strong> (đóng gói), <strong>Inheritance</strong> (kế thừa), <strong>Polymorphism</strong> (đa hình) và <strong>Abstraction</strong> (trừu tượng hóa). Phần này giúp bạn hiểu từng khái niệm và biết khi nào nên dùng, khi nào tránh.</p>

<section>
  <h3>1. Class và Object</h3>

  <h4>Định nghĩa</h4>
  <p><strong>Class</strong> là khuôn mẫu (blueprint) định nghĩa thuộc tính (fields) và hành vi (methods). <strong>Object</strong> là thể hiện cụ thể của class, được tạo bằng <code>new</code>. Mỗi object có vùng nhớ riêng trên Heap cho các thuộc tính của nó.</p>

  <h4>Ví dụ cơ bản</h4>
  <pre><code>public class Person {
  // Thuộc tính (fields) — mô tả trạng thái
  private String name;
  private int age;

  // Constructor — khởi tạo object
  public Person(String name, int age) {
    this.name = name;  // this tham chiếu tới object hiện tại
    this.age = age;
  }

  // Phương thức (method) — mô tả hành vi
  public String getName() {
    return name;
  }
}

// Sử dụng: tạo object và gọi method
Person p = new Person("Alice", 30);
System.out.println(p.getName());  // Alice</code></pre>

  <h4>Constructor — Khởi tạo object</h4>
  <p>Constructor có tên trùng với class, không có kiểu trả về. Nếu không khai báo, Java tạo <strong>default constructor</strong> (không tham số). Có thể có nhiều constructor (overload) để tạo object theo nhiều cách.</p>
  <pre><code>public class Person {
  private String name;
  private int age;

  // Constructor mặc định
  public Person() {
    this.name = "Unknown";
    this.age = 0;
  }

  // Constructor đầy đủ
  public Person(String name, int age) {
    this.name = name;
    this.age = age;
  }

  // Constructor copy — tạo bản sao từ object khác
  public Person(Person other) {
    this.name = other.name;
    this.age = other.age;
  }
}

Person p1 = new Person();
Person p2 = new Person("Bob", 25);
Person p3 = new Person(p2);  // p3 là bản sao của p2</code></pre>

  <h4>Từ khóa <code>this</code></h4>
  <p><code>this</code> tham chiếu tới object hiện tại. Dùng để: (1) phân biệt parameter và field khi tên trùng; (2) gọi constructor khác trong cùng class bằng <code>this(...)</code>; (3) truyền chính object làm tham số.</p>
  <pre><code>public class Person {
  private String name;

  public Person(String name) {
    this.name = name;  // this.name = field, name = parameter
  }

  public Person() {
    this("Unknown");   // Gọi constructor Person(String)
  }

  public void introduceTo(Person other) {
    System.out.println(this.name + " meets " + other.name);
  }
}</code></pre>

  <h4>Static — Thuộc về class, không thuộc object</h4>
  <p>Member <code>static</code> thuộc về class, dùng chung cho mọi object. Static field chỉ có một bản trong JVM; static method gọi qua tên class, không cần <code>new</code>.</p>
  <pre><code>public class Counter {
  private static int count = 0;  // Chia sẻ giữa mọi object

  public Counter() {
    count++;
  }

  public static int getCount() {
    return count;  // Không dùng this — static không có object
  }
}

Counter c1 = new Counter();
Counter c2 = new Counter();
System.out.println(Counter.getCount());  // 2 — gọi qua class</code></pre>

  <h4>Record (Java 16+) — Class bất biến đơn giản</h4>
  <p><code>record</code> tạo class immutable với constructor, getter, equals, hashCode, toString tự động. Phù hợp khi chỉ cần gom dữ liệu, không có logic phức tạp.</p>
  <pre><code>// Tương đương class với constructor, getter, equals, hashCode
public record Point(int x, int y) {
  // Có thể thêm method
  public double distance() {
    return Math.sqrt(x * x + y * y);
  }
}

Point p = new Point(3, 4);
System.out.println(p.x());      // 3 — getter tự sinh
System.out.println(p.distance());  // 5.0</code></pre>

  <table class="comparison-table">
    <caption>Class thường vs Record</caption>
    <thead>
      <tr>
        <th>Tiêu chí</th>
        <th>Class</th>
        <th>Record</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Mutable</td>
        <td>Có thể (setter)</td>
        <td>Không (immutable)</td>
      </tr>
      <tr>
        <td>Kế thừa</td>
        <td>extends class khác</td>
        <td>Chỉ implements interface</td>
      </tr>
      <tr>
        <td>Dùng khi</td>
        <td>Logic phức tạp, state thay đổi</td>
        <td>DTO, data carrier đơn giản</td>
      </tr>
    </tbody>
  </table>

  <section class="when-use">
    <h4>Khi nào nên dùng class?</h4>
    <p class="when-use-do"><strong>Nên dùng khi:</strong> Cần gom dữ liệu và hành vi liên quan; có nhiều thực thể cùng kiểu cần tái sử dụng; logic phức tạp hơn vài biến đơn lẻ.</p>
    <p class="when-use-avoid"><strong>Tránh khi:</strong> Logic rất đơn giản chỉ cần vài biến — dùng <code>record</code> (Java 16+); không có state cần quản lý — dùng static method hoặc utility class.</p>
  </section>
</section>
