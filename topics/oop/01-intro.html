<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gi&#7899;i thi&#7879;u - Java Core</title>
  <link rel="icon" type="image/svg+xml" href="../../favicon.svg">
  <link rel="stylesheet" href="../../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="topic-page">
  <header class="topic-header">
    <div class="topic-header-inner">
      <a href="../../index.html" class="topic-header-logo">Java Core</a>
      <nav class="topic-header-nav">
        <a href="../../index.html">Trang chủ</a>
      </nav>
    </div>
  </header>
  <div class="topic-layout">
    <nav class="topic-sidebar"><ul>
        <li><a href="../../index.html">Trang ch&#7911;</a>
        </li>
        <li><a href="../oop/01-intro.html" class="topic-sidebar-link--active">OOP</a>
        <ul class="topic-sub-nav">
          <li><a href="../oop/01-intro.html" class="topic-sidebar-link--active">Gi&#7899;i thi&#7879;u</a></li>
          <li><a href="../oop/02-encapsulation.html">Encapsulation</a></li>
          <li><a href="../oop/03-inheritance.html">Inheritance</a></li>
          <li><a href="../oop/04-polymorphism.html">Polymorphism</a></li>
          <li><a href="../oop/05-abstraction.html">Abstraction</a></li>
        </ul>
        </li>
        <li><a href="../collections/01-intro.html">Collections</a>
        </li>
        <li><a href="../io-nio/01-intro.html">I/O & NIO</a>
        </li>
        <li><a href="../concurrency/01-intro.html">Concurrency</a>
        </li>
        <li><a href="../jvm-memory/01-architecture.html">JVM & Memory</a>
        </li>
        <li><a href="../exception/01-hierarchy.html">Exception</a>
        </li>
        <li><a href="../generics/01-intro.html">Generics</a>
        </li>
        <li><a href="../lambda/01-intro.html">Lambda & Stream</a>
        </li>
</ul></nav>

    <main class="main-content topic-main">
      <div class="breadcrumb"><a href="../../index.html">Trang ch&#7911;</a> / <a href="../oop/01-intro.html">OOP</a> / Gi&#7899;i thi&#7879;u</div>
      <article class="topic-content">
        <h2>OOP - Lập trình hướng đối tượng</h2>

<p>Lập trình hướng đối tượng (OOP) là mô hình lập trình dựa trên khái niệm "đối tượng", chứa dữ liệu (thuộc tính) và mã (phương thức). Java là ngôn ngữ OOP thuần túy. OOP trong Java dựa trên bốn trụ cột: <strong>Encapsulation</strong> (đóng gói), <strong>Inheritance</strong> (kế thừa), <strong>Polymorphism</strong> (đa hình) và <strong>Abstraction</strong> (trừu tượng hóa). Phần này giúp bạn hiểu từng khái niệm và biết khi nào nên dùng, khi nào tránh.</p>

<section>
  <h3>Tổng quan từng phần</h3>
  <p>Mỗi phần gồm: <strong>Kỹ thuật</strong> (định nghĩa, cơ chế) và <strong>Ví dụ</strong> (code minh họa).</p>
  <table class="comparison-table">
    <caption>OOP — Kỹ thuật và Ví dụ</caption>
    <thead>
      <tr>
        <th>Phần</th>
        <th>Kỹ thuật</th>
        <th>Ví dụ</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>01 — Intro</strong></td>
        <td>Class, Object, Constructor, this, static, record</td>
        <td>Person class, Counter static, Point record</td>
      </tr>
      <tr>
        <td><strong>02 — Encapsulation</strong></td>
        <td>private, getter/setter, access modifier</td>
        <td>BankAccount, validation</td>
      </tr>
      <tr>
        <td><strong>03 — Inheritance</strong></td>
        <td>extends, super, override</td>
        <td>Animal → Dog, super()</td>
      </tr>
      <tr>
        <td><strong>04 — Polymorphism</strong></td>
        <td>Override, overload, dynamic dispatch</td>
        <td>Shape.draw(), method overload</td>
      </tr>
      <tr>
        <td><strong>05 — Abstraction</strong></td>
        <td>abstract class, interface</td>
        <td>abstract method, implements</td>
      </tr>
    </tbody>
  </table>
</section>

<section>
  <h3>Lộ trình học — Sơ đồ flow</h3>
  <p>Sơ đồ dưới đây thể hiện thứ tự học và mối liên hệ giữa các phần. Mỗi ô là một phần; mũi tên chỉ hướng tiếp theo.</p>

  <div class="flow-diagram">
    <script type="application/json" data-flow-tooltips>
    {"H1":{"title":"01 Intro - Class &amp; Object","detail":"<p><strong>Class</strong> - khuôn mẫu định nghĩa fields và methods. <strong>Object</strong> - thể hiện cụ thể, tạo bằng new.</p><p>Constructor - tên trùng class, không return type. this tham chiếu object hiện tại. static - thuộc class, dùng chung. record (Java 16+) - class immutable đơn giản.</p>"},"H2":{"title":"02 Encapsulation","detail":"<p><strong>Đóng gói</strong> - ẩn dữ liệu, truy cập qua method. private field, public getter/setter.</p><p>Validation trong setter. Access modifiers: private (class), protected (package + subclass), public (mọi nơi), default (package).</p>"},"H3":{"title":"03 Inheritance","detail":"<p><strong>extends</strong> - class con kế thừa cha. super() gọi constructor cha, phải dòng đầu trong constructor con.</p><p>@Override đánh dấu override. Khi nào dùng inheritance vs composition - composition thường linh hoạt hơn.</p>"},"H4":{"title":"04 Polymorphism","detail":"<p><strong>Override</strong> - class con thay method cha. Dynamic dispatch - runtime chọn method theo object thực (không phải reference type).</p><p><strong>Overload</strong> - cùng tên, khác tham số. Compile-time chọn. Dùng override cho đa hình, overload cho convenience.</p>"},"H5":{"title":"05 Abstraction","detail":"<p><strong>abstract class</strong> - có abstract method (chưa implement). Không thể new. Subclass phải implement.</p><p><strong>interface</strong> - contract, method abstract (trước Java 8). implements. Từ Java 8: default, static method. Khi nào abstract class vs interface - interface cho multiple inheritance của contract.</p>"}}
    </script>
    <pre class="mermaid">
flowchart TD
  subgraph Foundation [Foundation]
    direction LR
    H1("01 Intro")
    H2("02 Encapsulation")
    H1 -->|"Class, Object, record"| H2
  end
  subgraph Pillars [4 Trụ cột OOP]
    direction LR
    H3("03 Inheritance")
    H4("04 Polymorphism")
    H5("05 Abstraction")
    H3 -->|"extends, super"| H4 -->|"Override, overload"| H5
  end
  Foundation -->|"private, getter/setter"| Pillars
    </pre>
  </div>

  <table class="comparison-table">
    <caption>Chú thích từng phần</caption>
    <thead>
      <tr><th>Phần</th><th>Nội dung chính</th></tr>
    </thead>
    <tbody>
      <tr><td>01</td><td>Class, Object, constructor, this, static, record</td></tr>
      <tr><td>02</td><td>Access modifiers, getter/setter, validation</td></tr>
      <tr><td>03</td><td>extends, super(), @Override</td></tr>
      <tr><td>04</td><td>Override, overload, dynamic dispatch</td></tr>
      <tr><td>05</td><td>abstract class, interface, implements</td></tr>
    </tbody>
  </table>
</section>

<section>
  <h3>1. Class và Object</h3>

  <h4>Kỹ thuật — Định nghĩa</h4>
  <p><strong>Class</strong> là khuôn mẫu (blueprint) định nghĩa thuộc tính (fields) và hành vi (methods). <strong>Object</strong> là thể hiện cụ thể của class, được tạo bằng <code>new</code>. Mỗi object có vùng nhớ riêng trên Heap cho các thuộc tính của nó.</p>

  <h4>Ví dụ</h4>
  <pre><code>public class Person {
  // Thuộc tính (fields) — mô tả trạng thái
  private String name;
  private int age;

  // Constructor — khởi tạo object
  public Person(String name, int age) {
    this.name = name;  // this tham chiếu tới object hiện tại
    this.age = age;
  }

  // Phương thức (method) — mô tả hành vi
  public String getName() {
    return name;
  }
}

// Sử dụng: tạo object và gọi method
Person p = new Person("Alice", 30);
System.out.println(p.getName());  // Alice</code></pre>

  <h4>Constructor — Khởi tạo object</h4>
  <p>Constructor có tên trùng với class, không có kiểu trả về. Nếu không khai báo, Java tạo <strong>default constructor</strong> (không tham số). Có thể có nhiều constructor (overload) để tạo object theo nhiều cách.</p>
  <pre><code>public class Person {
  private String name;
  private int age;

  // Constructor mặc định
  public Person() {
    this.name = "Unknown";
    this.age = 0;
  }

  // Constructor đầy đủ
  public Person(String name, int age) {
    this.name = name;
    this.age = age;
  }

  // Constructor copy — tạo bản sao từ object khác
  public Person(Person other) {
    this.name = other.name;
    this.age = other.age;
  }
}

Person p1 = new Person();
Person p2 = new Person("Bob", 25);
Person p3 = new Person(p2);  // p3 là bản sao của p2</code></pre>

  <h4>Từ khóa <code>this</code></h4>
  <p><code>this</code> tham chiếu tới object hiện tại. Dùng để: (1) phân biệt parameter và field khi tên trùng; (2) gọi constructor khác trong cùng class bằng <code>this(...)</code>; (3) truyền chính object làm tham số.</p>
  <pre><code>public class Person {
  private String name;

  public Person(String name) {
    this.name = name;  // this.name = field, name = parameter
  }

  public Person() {
    this("Unknown");   // Gọi constructor Person(String)
  }

  public void introduceTo(Person other) {
    System.out.println(this.name + " meets " + other.name);
  }
}</code></pre>

  <h4>Static — Thuộc về class, không thuộc object</h4>
  <p>Member <code>static</code> thuộc về class, dùng chung cho mọi object. Static field chỉ có một bản trong JVM; static method gọi qua tên class, không cần <code>new</code>.</p>
  <pre><code>public class Counter {
  private static int count = 0;  // Chia sẻ giữa mọi object

  public Counter() {
    count++;
  }

  public static int getCount() {
    return count;  // Không dùng this — static không có object
  }
}

Counter c1 = new Counter();
Counter c2 = new Counter();
System.out.println(Counter.getCount());  // 2 — gọi qua class</code></pre>

  <h4>Record (Java 16+) — Class bất biến đơn giản</h4>
  <p><code>record</code> tạo class immutable với constructor, getter, equals, hashCode, toString tự động. Phù hợp khi chỉ cần gom dữ liệu, không có logic phức tạp.</p>
  <pre><code>// Tương đương class với constructor, getter, equals, hashCode
public record Point(int x, int y) {
  // Có thể thêm method
  public double distance() {
    return Math.sqrt(x * x + y * y);
  }
}

Point p = new Point(3, 4);
System.out.println(p.x());      // 3 — getter tự sinh
System.out.println(p.distance());  // 5.0</code></pre>

  <table class="comparison-table">
    <caption>Class thường vs Record</caption>
    <thead>
      <tr>
        <th>Tiêu chí</th>
        <th>Class</th>
        <th>Record</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Mutable</td>
        <td>Có thể (setter)</td>
        <td>Không (immutable)</td>
      </tr>
      <tr>
        <td>Kế thừa</td>
        <td>extends class khác</td>
        <td>Chỉ implements interface</td>
      </tr>
      <tr>
        <td>Dùng khi</td>
        <td>Logic phức tạp, state thay đổi</td>
        <td>DTO, data carrier đơn giản</td>
      </tr>
    </tbody>
  </table>

  <section class="when-use">
    <h4>Khi nào nên dùng class?</h4>
    <p class="when-use-do"><strong>Nên dùng khi:</strong> Cần gom dữ liệu và hành vi liên quan; có nhiều thực thể cùng kiểu cần tái sử dụng; logic phức tạp hơn vài biến đơn lẻ.</p>
    <p class="when-use-avoid"><strong>Tránh khi:</strong> Logic rất đơn giản chỉ cần vài biến — dùng <code>record</code> (Java 16+); không có state cần quản lý — dùng static method hoặc utility class.</p>
  </section>
</section>

      </article>
    </main>
  </div>
  <footer class="topic-footer">
    <p>Xây dựng bằng Java 17+ · Không dùng framework · Pure NIO</p>
  </footer>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@9/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      securityLevel: 'loose',
      theme: 'base',
      flowchart: { useMaxWidth: true, htmlLabels: true, curve: 'basis', padding: 20 },
      themeVariables: {
        primaryColor: '#FFFFFF',
        primaryTextColor: '#0F172A',
        primaryBorderColor: '#10B981',
        secondaryColor: '#ECFDF5',
        secondaryBorderColor: '#059669',
        tertiaryColor: '#F8FAFC',
        tertiaryBorderColor: '#10B981',
        lineColor: '#64748B',
        textColor: '#334155',
        fontFamily: 'Inter, system-ui, sans-serif',
        fontSize: '14px',
        clusterBkg: '#F8FAFC',
        clusterBorder: '#10B981',
        titleColor: '#0F172A',
        nodeBorder: '#10B981',
        defaultLinkColor: '#64748B',
        edgeLabelBackground: '#ECFDF5',
        edgeLabelColor: '#047857',
        mainBkg: '#FFFFFF',
        secondBkg: '#ECFDF5'
      }
    });
    window.addEventListener('load', function() {
      var tooltipEl = document.createElement('div');
      tooltipEl.className = 'flow-tooltip';
      tooltipEl.innerHTML = '<div class="flow-tooltip__title"></div><div class="flow-tooltip__body"></div>';
      document.body.appendChild(tooltipEl);
      function getNodeIdFromElement(el) {
        if (!el) return null;
        var dataId = el.getAttribute && el.getAttribute('data-id');
        if (dataId) return dataId;
        var id = el.id;
        if (!id) return null;
        if (id.indexOf('flowchart-') === 0) {
          var rest = id.slice(10);
          var dash = rest.indexOf('-');
          return dash >= 0 ? rest.slice(0, dash) : rest;
        }
        return id;
      }
      function attachTooltips() {
        document.querySelectorAll('.flow-diagram svg rect').forEach(function(r) {
          r.setAttribute('rx', '8');
          r.setAttribute('ry', '8');
        });
        var attached = 0;
        document.querySelectorAll('.flow-diagram').forEach(function(diagram, di) {
          var script = diagram.querySelector('script[type="application/json"][data-flow-tooltips]');
          if (!script) return;
          var data;
          try { data = JSON.parse(script.textContent); } catch (e) { return; }
          var svg = diagram.querySelector('svg');
          if (!svg) return;
          if (diagram.hasAttribute('data-tooltip-delegated')) return;
          diagram.setAttribute('data-tooltip-delegated', '1');
          diagram.querySelectorAll('g.node').forEach(function(g) { g.style.pointerEvents = 'auto'; });
          var onOver = function(e) {
            var g = e.target.closest && e.target.closest('g.node');
            if (!g) return;
            var nodeId = getNodeIdFromElement(g);
            if (!nodeId) return;
            var tip = data[nodeId];
            if (!tip || !tip.detail) return;
            tooltipEl.querySelector('.flow-tooltip__title').textContent = tip.title || nodeId;
            tooltipEl.querySelector('.flow-tooltip__body').innerHTML = tip.detail;
            tooltipEl.style.left = '';
            tooltipEl.style.top = '';
            tooltipEl.classList.add('is-visible');
            var rect = g.getBoundingClientRect();
            var x = rect.left + rect.width / 2;
            var y = rect.top - 10;
            requestAnimationFrame(function() {
              var w = tooltipEl.offsetWidth;
              var h = tooltipEl.offsetHeight;
              tooltipEl.style.left = Math.max(12, Math.min(x - w / 2, window.innerWidth - w - 12)) + 'px';
              tooltipEl.style.top = Math.max(12, y - h) + 'px';
            });
          };
          var onOut = function(e) {
            var related = e.relatedTarget;
            if (related && diagram.contains(related)) return;
            tooltipEl.classList.remove('is-visible');
          };
          diagram.addEventListener('mouseover', onOver);
          diagram.addEventListener('mouseout', onOut);
          attached++;
        });
        return attached;
      }
      var delays = [150, 400, 800];
      delays.forEach(function(delay, i) {
        setTimeout(function() {
          var n = attachTooltips();
          if (n === 0 && i === delays.length - 1) {
            setTimeout(attachTooltips, 500);
          }
        }, delay);
      });
    });
  </script>
</body>
</html>
